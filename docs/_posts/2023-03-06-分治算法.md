---
date: 2023-03-06
category: 算法
---
[转载:程序员麻辣烫](https://blog.csdn.net/shida219/article/details/108446360)

分治法将一个难以直接解决的大问题划分成一些规模较小的子问题，分别求解各个子问题，再合并子问题的解得到原问题的解。  
## 设计思想
1. 大问题划分成一些规模较小的子问题，以便各个击破，分而治之
2. 最好使子问题的规模大小相等
3. 最好使各子问题之间相互独立。如果子问题不独立，分治法需要重复的求解公共的子问题，此时虽然也可以用分治法，但一般用动态规划法较好

## 求解过程
1. 划分：即分治，划分为小问题
2. 求解子问题：一般用递归的方法求解各个子问题，有时递归也可以用循环来实现
3. 合并：把各个子问题的解合并起来

## 递归
分治与递归就像一对孪生兄弟

递归：就是子程序（或函数）直接调用自己或者通过一系列调用语句间接调用自己，是一种描述问题和解决问题的基本方法

递归通常用来解决结构自相似的问题。

递归有两个基本要素：

边界条件：确定递归到何时终止，也称为递归出口
递归模式：大问题是如何分解为小问题的，也称为递归体
递归函数只有具备了这两个要素，才能在有限次计算后得出结果。

## 排序问题中的分治法
### 归并排序
二路归并的分治策略是：

划分：将待排序序列r1，r2……rn划分为两个长度相等的子序列r1，……rn/2和rn/2+1，……rn

求解子问题：分别对这两个子序列进行归并排序，得到两个有序子序列

合并：将这两个有序子序列合并成一个有序序列  
```go
func sortDivide(nums []int) []int {
	if nums == nil || len(nums) <= 1 {
		return nums
	}
	sortSlice(nums, 0, len(nums)-1)
	return nums
}

/**
 *left,rightslice的起始结束索引
 */
func sortSlice(nums []int, left, right int) {
	if left >= right {
		return
	}
	mid := left + (right-left)/2
	//左部分排序
	sortSlice(nums, left, mid)
	//右部分排序
	sortSlice(nums, mid+1, right)
	//合并
	merge(nums, left, mid, right)
}

func merge(nums []int, left, mid, right int) {
	i := left
	j := mid + 1
	for i <= mid && j <= right {
		if nums[i] < nums[j] {
			j++
		} else if nums[i] > nums[j] {
			nums[i], nums[j] = nums[j], nums[i]
			i++
		}
	}
}
```

## 快速排序
归并排序是按照记录在序列中的位置对序列进行划分的，而快速排序是按照记录的值对序列进行划分的。

快速排序的分治策略是：

划分：选定一个记录作为轴值，以轴值为基准将序列划分为两个子序列r1，……，ri-1和ri+1，……，rn，轴值的位置i在划分的过程中确定，前子序列都小于等于轴值，后子序列都大于等于轴值
求解子问题：分别对划分后的每一个子序列递归处理
合并：因为子序列的排序是在当前数组中，所以合并不需要执行任何操作
注意，轴值不需要选定，核心在于划分出两个子序列，前子序列都小于等于某个值，后子序列都大于等于某个值
```go
func quickSort31(arr []int) {
	if arr == nil || len(arr) <= 1 {
		return
	}
	quickSort32(arr, 0, len(arr)-1)
}

func quickSort32(arr []int, left, right int) {
	if left >= right {
		return
	}
	cur := left + 1
	pivot := arr[left]
	lIndex, rIndex := left, right
	for cur <= right {
		if arr[cur] < pivot {
			arr[cur], arr[left] = arr[left], arr[cur]
			left++
			cur++
		} else if arr[cur] > pivot {
			arr[cur], arr[right] = arr[right], arr[cur]
			right--
		} else {
			cur++
		}
	}
	quickSort32(arr, lIndex, left)
	quickSort32(arr, right+1, rIndex)
}
```

## 组合问题中的分治法
最大子段和问题
给定由n个整数（可能有负数）组成的序列(a1,a2,……,an)，最大子段和问题要求该序列某个区间范围之内和最大，当所有整数均为负整数时，其最大字段和为0。如(-20,11,-4,13,-5,2)，最大子段和为11-4+13=20

用分治策略求解最大子段和：

划分：按照平衡子问题原则，将序列(a1,a2,……,an)划分成长度相同的两个子序列(a1,……,a[n/2])和(a[n/2+1],……,an)，会有三种情况
a1,a2,……,an的最大字段和等于a1,……,a[n/2]的最大子段和
a1,a2,……,an的最大字段和等于a[n/2+1],……,an的最大子段和
a1,a2,……,an的最大字段和等于ai+……+aj, 1<=i<=2/n，n/2+1<=j<=n
求解子问题：对于划分中情况1和情况2可以递归求解，情况3需要分别计算s1=max(a1+……+a[n/2])，s2=max(a[n/2+1]+……+a[n])，则s1+s2为情况3的最大子段和
合并：比较在划分阶段的三种情况下的最大子段和，取三者中较大者为原问题的解

这种类型的题，能考虑使用分治法，感觉已经领悟了分治的核心：划分-求解子问题-合并。蛮力法做差不多是O(n^2)，分治法时间复杂度O(nlog2n)。

另外感觉这种题目，可能使用动态规划效果会更好一些。



## 总结
分治法能够极大的提高算法速度，而且分治法和迭代几乎是孪生关系。

使用分治法，需要完全领悟划分-求解子问题-合并的核心。推导出递归时需要设定的边界条件和迭代模式。

这里面比较重要的类型有

排序问题：归并排序、快速排序

组合问题：最大子段和问题、棋盘覆盖问题、循环赛日程安排问题

几何问题：最近对问题、凸包问题

归并排序、快速排序、最大子段和问题、棋盘覆盖问题建议自己尝试一下，因为排序算法是必须要练习的，最大子段和问题涉及到子问题有关联，棋盘覆盖问题涉及到二维数组。
