---
category: GO
date: 2023-03-28 10:01
---
[转载: 程序员麻辣烫](https://mp.weixin.qq.com/s?__biz=MzUzNzAzMTc3MA==&mid=2247484028&idx=1&sn=4e99d96e54e325fbdb5b6e36fea2577b&scene=21#wechat_redirect)

## 概述
《分布式系统概念与设计》一书中对分布式系统概念的定义如下：分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统

分布式系统的设计目标一般包括如下几个方面

可用性：可用性是分布式系统的核心需求，其用于衡量一个分布式系统持续对外提供服务的能力。 

可扩展性：增加机器后不会改变或极少改变系统行为，并且能获得近似线性的性能提升。 

容错性：系统发生错误时，具有对错误进行规避以及从错误中恢复的能力。 

性能：对外服务的响应延时和吞吐率要能满足用户的需求。

分布式架构比单体式架构拥有更多的挑战

节点之间的网络通信是不可靠的，存在网络延时和丢包等情况。

存在节点处理错误的情况，节点自身随时也有宕机的可能。

同步调用使系统变得不具备可扩展性。

CAP原理
提到分布式系统，就不得不提CAP原理。

CAP的完整定义为:

C：Consistency（一致性）。这里的一致性特指强一致，通俗地说，就是所有节点上的数据时刻保持同步。一致性严谨的表述是原子读写，即所有读写都应该看起来是“原子”的，或串行的。所有的读写请求都好像是经全局排序过的一样，写后面的读一定能读到前面所写的内容。 

A：Availability（可用性）。任何非故障节点都应该在有限的时间内给出请求的响应，不论请求是否成功。 

P：Tolerance to the partition of network（分区容忍性）。当发生网络分区时（即节点之间无法通信），在丢失任意多消息的情况下，系统仍然能够正常工作。

CAP原理具有重大的指导意义：在任何分布式系统中，可用性、一致性和分区容忍性这三个方面都是相互矛盾的，三者不可兼得，最多只能取其二。
直观的说明如下：

1）AP满足但C不满足：如果既要求系统高可用又要求分区容错，那么就要放弃一致性了。因为一旦发生网络分区（P），节点之间将无法通信，为了满足高可用（A），每个节点只能用本地数据提供服务，这样就会导致数据的不一致（!C）。一些信奉BASE（Basic Availability, Soft state, Eventually Consistency）原则的NoSQL数据库（例如，Cassandra、CouchDB等）往往会放宽对一致性的要求（满足最终一致性即可），以此来换取基本的可用性。

2）CP满足但A不满足：如果要求数据在各个服务器上是强一致的（C），然而网络分区（P）会导致同步时间无限延长，那么如此一来可用性就得不到保障了（!A）。坚持事务ACID（原子性、一致性、隔离性和持久性）的传统数据库以及对结果一致性非常敏感的应用（例如，金融业务）通常会做出这样的选择。

3）CA满足但P不满足：指的是如果不存在网络分区，那么强一致性和可用性是可以同时满足的。

正如热力学第二定律揭示了任何尝试发明永动机的努力都是徒劳的一样，CAP原理明确指出了完美满足CAP三种属性的分布式系统是不存在的。

了解CAP原理的目的在于，其能够帮助我们更好地理解实际分布式协议实现过程中的取舍。

一致性
分布式存储系统通常会通过维护多个副本来进行容错，以提高系统的可用性。这就引出了分布式存储系统的核心问题——如何保证多个副本的一致性？

“一致性”有三种含义：

Coherence这个单词只在Cache Coherence场景下出现过，其所关注的是多核共享内存的CPU架构下，各个核的Cache上的数据应如何保持一致。

Consensus是共识，它强调的是多个提议者就某件事情达成共识，其所关注的是达成共识的过程，例如Paxos协议、Raft选举等。Consensus属于replication protocol的范畴。

Consistency表达的含义相对复杂一些，广义上说，它描述了系统本身的不变量的维护程度对上层业务客户端的影响，以及该系统的并发状态会向客户端暴露什么样的异常行为。CAP、ACID中的C都有这层意思。

这里重点讨论的分布式系统中的一致性问题，属于上文中提到的Consensus和Consistency范畴。

分布式系统的一致性是一个具备容错能力的分布式系统需要解决的基本问题。通俗地讲，一致性就是不同的副本服务器认可同一份数据。一旦这些服务器对某份数据达成了一致，那么该决定便是最终的决定，且未来也无法推翻。

这里有一点需要注意：一致性与结果的正确性没有关系，而是系统对外呈现的状态是否一致（统一）。例如，所有节点都达成一个错误的共识也是一致性的一种表现。

一致性协议就是用来解决一致性问题的，它能使得一组机器像一个整体一样工作，即使其中的一些机器发生了错误也能正常工作。正因为如此，一致性协议在大规模分布式系统中扮演着关键角色。

一致性协议从20世纪80年代开始研究，一致性协议衍生出了很多算法。衡量一致性算法的标准具体如下：

可终止性：非失败进程在有限的时间内能够做出决定，等价于liveness。

一致性：所有的进程必须对最终的决定达成一致，等价于safety。

合法性：算法做出的决定值必须在其他进程（客户端）的期望值范围之内。即客户端请求回答“是”或“否”时，不能返回“不确定”。

一致性模型
在给定了与操作和状态相关的一些规则的情况下，系统中的操作历史应该总是遵循这些规则。我们称这些规则为一致性模型

一致性模型分述
对于一致性，可以分别从客户端和服务端两个不同的视角来理解。

从客户端来看，一致性主要是指多并发访问时如何获取更新过的数据的问题。

从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终的一致性。

因此，**可以从两个角度来查看一致性模型：以数据为中心的一致性模型和以用户为中心的一致性模型。**

以数据为中心的一致性模型
实现以下这几种一致性模型的难度会依次递减，对一致性强度的要求也依次递减。

严格一致性（Strong Consistency）

严格一致性也称强一致性，原子一致性或者是可线性化（Linearizability），是要求最高的一致性模型。严格一致性的要求具体如下:

严格一致性维护的是一个绝对全局时间顺序。单机系统遵守严格一致性，但对于分布式系统，为每个操作都分配一个准确的全局时间戳是不可能实现的，所以严格一致性只是存在于理论中的一致性模型。

任何一次读都能读到某个数据的最近一次写的数据。

系统中的所有进程，看到的操作顺序，都与全局时钟下的顺序一致。

顺序一致性（Sequential Consistency）

顺序一致性，也称为可序列化，比严格一致性要求弱一点，但也是能够实现的最高级别的一致性模型。

因为全局时钟导致严格一致性很难实现，因此顺序一致性放弃了全局时钟的约束，改为分布式逻辑时钟实现。顺序一致性是指所有的进程都以相同的顺序看到所有的修改。读操作未必能够及时得到此前其他进程对同一数据的写更新，但是每个进程读到的该数据不同值的顺序却是一致的。

满足顺序一致性的存储系统需要一个额外的逻辑时钟服务。

下图解释了严格一致性和顺序一致性

a) 顺序一致性，从这两个进程的角度来看，顺序应该是这样的：Write(y, 2)→Read(x, 0)→Write(x, 4)→Read(y, 2)，完全没有冲突

b) 严格一致性，从两个进程看到的操作顺序与全局时钟的顺序一样，都是Write(y, 2)→Write(x, 4)→Read(x, 4)→Read(y, 2)。

c) 不满足顺序一致性，Write(x, 4)→Read(y, 0)→Write(y, 2)→Read(x, 0)，这个有冲突
<img src="/my_pic/一致性.png">

